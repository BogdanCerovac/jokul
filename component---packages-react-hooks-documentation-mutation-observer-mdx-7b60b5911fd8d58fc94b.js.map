{"version":3,"sources":["webpack:///../packages/react-hooks/src/useReducedMotion/useReducedMotion.tsx","webpack:///../packages/react-hooks/src/animation.tsx","webpack:///../packages/react-hooks/src/useClickOutside.ts","webpack:///../packages/react-hooks/src/useScreen/state.ts","webpack:///../packages/react-hooks/src/useMutationObserver/useMutationObserver.ts","webpack:///../packages/react-hooks/src/useScreen/useScreen.ts","webpack:///../packages/react-hooks/src/useScrollIntoView/useScrollIntoView.tsx","webpack:///../packages/react-hooks/documentation/MutationObserverExample.tsx","webpack:///../packages/react-hooks/documentation/mutationObserver.mdx","webpack:///../packages/react-hooks/src/useKeyListener.ts","webpack:///../packages/react-hooks/src/useFocusOutside.ts","webpack:///../packages/react-hooks/src/useIntersectionObserver/useIntersectionObserver.ts"],"names":["useReducedMotion","useState","window","matchMedia","matches","prefersReducedMotion","setPrefersReducedMotion","useEffect","mediaQueryList","listener","event","addListener","removeListener","useAnimatedHeight","isOpen","raf1","useRef","raf2","elementRef","firstRender","handleTransitionEnd","element","getElement","removeAttribute","runAnimation","useCallback","current","style","display","overflow","height","scrollHeight","requestAnimationFrame","useLayoutEffect","addEventListener","removeEventListener","r1","r2","cancelAnimationFrame","el","useClickOutside","ref","fn","handleClickOutside","contains","target","React","document","ActionTypes","hasWindowWithMutationObserver","MutationObserver","useMutationObserver","targetRef","onObservation","config","observerRef","observer","disconnect","observe","actionTypes","resized","setDeviceSize","width","isSmallDevice","breakpoints","small","isMediumDevice","medium","isLargeDevice","large","isXlDevice","isPortrait","isLandscape","inner","initialState","init","innerWidth","innerHeight","reducer","state","type","useScreen","useReducer","device","deviceDispatch","handleScreenChange","useScrollIntoView","timeout","autoScroll","options","behavior","scrollIntoView","scrollFn","setTimeout","clearTimeout","MutationObserverExample","setIsOpen","listOfMutations","appendToMutationList","mutationTargetRef","listRef","mutationList","map","item","textContent","characterData","subtree","className","onClick","length","idx","key","_frontmatter","makeShortcode","name","props","console","warn","Ingress","ComponentExample","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","mdxType","parentName","component","isMDXComponent","useKeyListener","keys","handleKeyDown","includes","useFocusOutside","handleFocusOutside","hasWindowWithIntersectionObserver","IntersectionObserver","useIntersectionObserver","onIntersect","fallback"],"mappings":"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","file":"component---packages-react-hooks-documentation-mutation-observer-mdx-7b60b5911fd8d58fc94b.js","sourcesContent":["import { useState, useEffect } from \"react\";\n\nconst PREFERS_REDUCED_MOTION = \"(prefers-reduced-motion: no-preference)\";\nconst getInitialState = () => {\n    if (typeof window !== \"undefined\" && window.matchMedia) {\n        return !window.matchMedia(PREFERS_REDUCED_MOTION).matches;\n    }\n    return false;\n};\n\nexport const useReducedMotion = (): boolean => {\n    const [prefersReducedMotion, setPrefersReducedMotion] = useState(getInitialState());\n\n    useEffect(() => {\n        let mediaQueryList: MediaQueryList;\n        let listener: (event: MediaQueryListEvent) => void;\n        if (typeof window !== \"undefined\" && window.matchMedia) {\n            mediaQueryList = window.matchMedia(PREFERS_REDUCED_MOTION);\n            listener = (event: MediaQueryListEvent) => setPrefersReducedMotion(!event.matches);\n            mediaQueryList?.addListener(listener);\n        }\n\n        return () => {\n            mediaQueryList?.removeListener(listener);\n        };\n    }, []);\n\n    return prefersReducedMotion;\n};\n","import { MutableRefObject, useEffect, useRef, RefObject, useCallback, useLayoutEffect } from \"react\";\nimport { useReducedMotion } from \"./useReducedMotion/useReducedMotion\";\n\ninterface HTMLElementOrCoreToggleElement<T extends HTMLElementOrCoreToggleElement<T>> extends HTMLElement {\n    el?: T; // Hack and workaround until https://github.com/nrkno/custom-element-to-react/pull/17 has landed\n}\n\nexport function useAnimatedHeight<T extends HTMLElement>(isOpen: boolean): [RefObject<T>, () => void] {\n    const raf1 = useRef<number>();\n    const raf2 = useRef<number>();\n    const elementRef = useRef<T>(null);\n    const firstRender = useRef<boolean>(true);\n    const prefersReducedMotion = useReducedMotion();\n\n    function handleTransitionEnd() {\n        const element = getElement(elementRef);\n        if (element) {\n            element.removeAttribute(\"style\");\n        }\n    }\n\n    const runAnimation = useCallback(() => {\n        if (prefersReducedMotion) {\n            return;\n        }\n        if (firstRender.current) {\n            return; // Do not play animation on first render\n        }\n        const element = getElement(elementRef);\n        if (element) {\n            element.style.display = \"block\";\n            element.style.overflow = \"hidden\";\n            if (isOpen) {\n                element.style.height = \"0\";\n                element.style.height = `${element.scrollHeight}px`;\n            } else {\n                // If the scrollHeight is 0 it means that we are transitioning from height 0 -> 0.\n                // This causes the \"transitionend\"-event to never fire and the element gets stuck with\n                // style: height: 0; display: block; overflow:hidden\n                if (element.scrollHeight === 0) {\n                    element.removeAttribute(\"style\");\n                    return;\n                }\n\n                element.style.height = `${element.scrollHeight}px`;\n\n                raf1.current = requestAnimationFrame(() => {\n                    raf2.current = requestAnimationFrame(() => {\n                        element.style.height = `${0}px`;\n                    });\n                });\n            }\n        }\n    }, [isOpen]);\n\n    useLayoutEffect(() => {\n        runAnimation();\n    }, [isOpen, runAnimation]);\n\n    useEffect(() => {\n        const element = getElement(elementRef);\n        if (element) {\n            element.addEventListener(\"transitionend\", handleTransitionEnd);\n        }\n\n        return () => {\n            if (element) {\n                element.removeEventListener(\"transitionend\", handleTransitionEnd);\n            }\n        };\n    }, [isOpen]);\n\n    useEffect(() => {\n        const r1 = raf1.current;\n        const r2 = raf2.current;\n        firstRender.current = false;\n        return () => {\n            r1 && cancelAnimationFrame(r1);\n            r2 && cancelAnimationFrame(r2);\n        };\n    }, [raf1, raf2]);\n\n    return [elementRef, runAnimation];\n}\n\nfunction getElement(elementRef: MutableRefObject<HTMLElementOrCoreToggleElement<HTMLElement> | null>) {\n    // Workaround to handle custom elements from NRK Core components until this lands:\n    // https://github.com/nrkno/custom-element-to-react/pull/17\n    return elementRef.current && (elementRef.current.el || elementRef.current);\n}\n","import React, { RefObject } from \"react\";\n\nexport function useClickOutside(ref: RefObject<HTMLElement> | null, fn: () => void) {\n    function handleClickOutside(event: MouseEvent) {\n        if (ref?.current && !ref.current.contains(event.target as Node)) {\n            fn();\n        }\n    }\n\n    React.useEffect(() => {\n        if (ref) {\n            document && document.addEventListener(\"click\", handleClickOutside);\n        }\n        return () => {\n            if (ref) {\n                document && document.removeEventListener(\"click\", handleClickOutside);\n            }\n        };\n    });\n}\n","import { breakpoints } from \"@fremtind/jkl-core\";\n\nexport interface State {\n    isSmallDevice: boolean;\n    isMediumDevice: boolean;\n    isLargeDevice: boolean;\n    isXlDevice: boolean;\n    isLandscape: boolean;\n    isPortrait: boolean;\n    inner: {\n        height: number;\n        width: number;\n    };\n}\n\nenum ActionTypes {\n    resized = \"WINDOW_RESIZED\",\n}\n\ninterface Action {\n    type: ActionTypes;\n    width: number;\n    height: number;\n}\n\nexport const actionTypes = {\n    resized: ActionTypes.resized,\n};\n\nconst setDeviceSize = (width: number, height: number) => ({\n    isSmallDevice: width < breakpoints.small,\n    isMediumDevice: width > breakpoints.small && width < breakpoints.medium,\n    isLargeDevice: width > breakpoints.medium && width < breakpoints.large,\n    isXlDevice: width > breakpoints.large,\n    isPortrait: height >= width,\n    isLandscape: height < width,\n    inner: {\n        height,\n        width,\n    },\n});\n\nexport const initialState = {\n    isSmallDevice: false,\n    isMediumDevice: false,\n    isLargeDevice: false,\n    isXlDevice: false,\n    isLandscape: false,\n    isPortrait: false,\n    inner: {\n        height: 0,\n        width: 0,\n    },\n};\n\nexport const init = () => {\n    const width = typeof window !== \"undefined\" ? window.innerWidth : 0;\n    const height = typeof window !== \"undefined\" ? window.innerHeight : 0;\n    return setDeviceSize(width, height);\n};\n\nexport const reducer = (state: State, { type, width, height }: Action) => {\n    switch (type) {\n        case actionTypes.resized:\n            return {\n                ...state,\n                ...setDeviceSize(width, height),\n            };\n    }\n};\n","import { useEffect, useRef, RefObject } from \"react\";\n\nconst hasWindowWithMutationObserver = () => typeof window !== \"undefined\" && typeof MutationObserver !== \"undefined\";\n\nexport const useMutationObserver = (\n    targetRef: RefObject<HTMLElement>,\n    onObservation: MutationCallback,\n    config?: Partial<MutationObserverInit>,\n) => {\n    const observerRef = useRef<MutationObserver>(null);\n\n    useEffect(() => {\n        let observer = observerRef.current;\n\n        if (hasWindowWithMutationObserver()) {\n            const target = targetRef.current;\n\n            if (observer) {\n                observer.disconnect();\n            }\n\n            observer = new MutationObserver(onObservation);\n\n            if (target) {\n                observer.observe(target, config);\n            }\n        }\n        return () => {\n            if (hasWindowWithMutationObserver() && observer) {\n                observer.disconnect();\n            }\n        };\n    }, [targetRef, onObservation, config]);\n};\n","import { useEffect, useReducer } from \"react\";\nimport { reducer, initialState, init, actionTypes } from \"./state\";\n\nexport const useScreen = () => {\n    const [device, deviceDispatch] = useReducer(reducer, initialState, init);\n\n    const handleScreenChange = () =>\n        requestAnimationFrame(() =>\n            deviceDispatch({ type: actionTypes.resized, width: window.innerWidth, height: window.innerHeight }),\n        );\n\n    useEffect(() => {\n        if (typeof window !== \"undefined\") {\n            window.addEventListener(\"resize\", handleScreenChange);\n        }\n        return () => {\n            if (typeof window !== \"undefined\") {\n                window.removeEventListener(\"resize\", handleScreenChange);\n            }\n        };\n    }, []);\n\n    return { ...device };\n};\n","import { useEffect, RefObject } from \"react\";\n\ntype ValueOf<T> = T[keyof T];\n\ninterface Props {\n    ref: RefObject<ValueOf<HTMLElementTagNameMap>>;\n    timeout?: number;\n    autoScroll?: boolean;\n    options?: ScrollIntoViewOptions;\n}\n\nexport const useScrollIntoView = ({ ref, timeout = 0, autoScroll = true, options = { behavior: \"smooth\" } }: Props) => {\n    const scrollIntoView = () => {\n        if (ref?.current) {\n            ref.current.scrollIntoView(options);\n        }\n    };\n    useEffect(() => {\n        if (!autoScroll) {\n            return;\n        }\n        const scrollFn = setTimeout(scrollIntoView, timeout);\n        return () => clearTimeout(scrollFn);\n    }, [ref, timeout, autoScroll]);\n\n    return [scrollIntoView];\n};\n","import React, { useState, useRef } from \"react\";\nimport { useMutationObserver } from \"../src\";\n\nconst MutationObserverExample = () => {\n    const [isOpen, setIsOpen] = useState(false);\n    const [listOfMutations, appendToMutationList] = useState<string[]>([]);\n    const mutationTargetRef = useRef(null);\n    const listRef = useRef<string[]>();\n\n    listRef.current = listOfMutations;\n    const onObservation = (mutationList: MutationRecord[]) => {\n        appendToMutationList([\n            ...(listRef.current || []),\n            ...mutationList.map((item) => item.target.textContent || \"\"),\n        ]);\n    };\n\n    useMutationObserver(mutationTargetRef, onObservation, { characterData: true, subtree: true });\n    return (\n        <section>\n            <button\n                className=\"jkl-button jkl-button--secondary jkl-spacing--right-1\"\n                onClick={() => setIsOpen(!isOpen)}\n            >\n                Endre status\n            </button>\n            <button className=\"jkl-button jkl-button--tertiary\" onClick={() => appendToMutationList([])}>\n                Nullstill liste\n            </button>\n            <p ref={mutationTargetRef} className=\"jkl-spacing--top-1 jkl-body\">\n                Nåværende status: <strong>{isOpen ? \"Åpen\" : \"Lukket\"}</strong>\n                <br />\n                Liste over endringer:\n            </p>\n            {listOfMutations.length !== 0 && (\n                <ul className=\"jkl-list jkl-list--unordered jkl-body\">\n                    {listOfMutations.map((item, idx) => (\n                        <li className=\"jkl-list__item\" key={idx}>\n                            {item}\n                        </li>\n                    ))}\n                </ul>\n            )}\n        </section>\n    );\n};\n\nexport default MutationObserverExample;\n","import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/jokul/jokul/portal/src/components/Layout/DocPageLayout.tsx\";\nimport MutationObserverExample from \"./MutationObserverExample\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst Ingress = makeShortcode(\"Ingress\");\nconst ComponentExample = makeShortcode(\"ComponentExample\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n    <Ingress mdxType=\"Ingress\">Med useMutationObserver kan du lytte på endringer i DOMet.</Ingress>\n    <p>{`Dette er en tynn wrapper over MutationObserver APIet som gjør det lettere å ta det i bruk i React. Den er nyttig om du f.eks. ønsker å spore når en bruker trykker på et element der du ikke har tilgang på `}<inlineCode parentName=\"p\">{`onChange`}</inlineCode>{`-funksjonen, som `}<inlineCode parentName=\"p\">{`Accordion`}</inlineCode>{`.`}</p>\n    <ComponentExample component={MutationObserverExample} mdxType=\"ComponentExample\" />\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      ","import { RefObject, useEffect } from \"react\";\n\nexport function useKeyListener(\n    ref: RefObject<HTMLElement> | null,\n    keys: string[] | string | null,\n    fn: (event: KeyboardEvent) => void,\n) {\n    if (typeof keys === \"string\") {\n        keys = [keys];\n    }\n    function handleKeyDown(event: KeyboardEvent) {\n        if (keys && !keys.includes(event.key)) {\n            return;\n        }\n        fn(event);\n    }\n\n    useEffect(() => {\n        const element = ref && ref.current;\n        if (element) {\n            element.addEventListener(\"keydown\", handleKeyDown);\n        }\n        return () => {\n            if (element) {\n                element.removeEventListener(\"keydown\", handleKeyDown);\n            }\n        };\n    });\n}\n","import React, { RefObject } from \"react\";\n\nexport function useFocusOutside(ref: RefObject<HTMLElement> | null, fn: () => void) {\n    function handleFocusOutside(event: FocusEvent) {\n        if (ref?.current && !ref.current.contains(event.target as Node)) {\n            fn();\n        }\n    }\n\n    React.useEffect(() => {\n        if (ref) {\n            document && document.addEventListener(\"focusin\", handleFocusOutside);\n        }\n        return () => {\n            if (ref) {\n                document && document.removeEventListener(\"focusin\", handleFocusOutside);\n            }\n        };\n    });\n}\n","import { useEffect, useRef, RefObject } from \"react\";\n\nconst hasWindowWithIntersectionObserver = () =>\n    typeof window !== \"undefined\" && typeof IntersectionObserver !== \"undefined\";\n\nexport const useIntersectionObserver = (\n    targetRef: RefObject<HTMLElement | SVGElement>,\n    onIntersect: IntersectionObserverCallback,\n    fallback: VoidFunction,\n    options?: Partial<IntersectionObserverInit>,\n) => {\n    const observerRef = useRef<IntersectionObserver>(null);\n\n    useEffect(() => {\n        let observer = observerRef.current;\n        if (hasWindowWithIntersectionObserver()) {\n            const target = targetRef.current;\n\n            if (observer) {\n                observer.disconnect();\n            }\n\n            observer = new IntersectionObserver(onIntersect, options);\n\n            if (target) {\n                observer.observe(target);\n            }\n        } else {\n            fallback();\n        }\n        return () => {\n            if (hasWindowWithIntersectionObserver() && observer) {\n                observer.disconnect();\n            }\n        };\n    }, [targetRef, onIntersect, fallback, options]);\n};\n"],"sourceRoot":""}