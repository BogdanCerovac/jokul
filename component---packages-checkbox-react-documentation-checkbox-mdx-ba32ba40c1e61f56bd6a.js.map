{"version":3,"sources":["webpack:///../packages/checkbox-react/src/Checkbox.tsx","webpack:///../packages/checkbox-react/documentation/Example.tsx","webpack:///../packages/checkbox-react/documentation/Checkbox.mdx","webpack:///../node_modules/nanoid/index.browser.js"],"names":["Checkbox","React","forwardRef","ref","children","name","value","checked","invalid","className","inline","forceCompact","inverted","eventHandlers","componentClassNames","classNames","id","useState","nanoid","data-testid","aria-invalid","type","htmlFor","Example","boolValues","setChecked","checked2","setChecked2","onChange","_frontmatter","makeShortcode","props","console","warn","Ingress","ComponentExample","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","mdxType","component","knobs","boolProps","parentName","isMDXComponent","size","arguments","length","undefined","bytes","crypto","getRandomValues","Uint8Array","byte","toString","toUpperCase"],"mappings":"yUAmBO,IAAMA,EAAWC,IAAMC,YAC1B,WAaIC,GACC,IAZGC,EAYH,EAZGA,SACAC,EAWH,EAXGA,KACAC,EAUH,EAVGA,MACAC,EASH,EATGA,QACAC,EAQH,EARGA,QACAC,EAOH,EAPGA,UAOH,IANGC,cAMH,SALGC,EAKH,EALGA,aACAC,EAIH,EAJGA,SACGC,E,oIAGN,mGACKC,EAAsBC,IAAW,eAAgBN,EAAW,CAC9D,wBAAyBE,EACzB,uBAAwBD,EACxB,sBAAuBF,EACvB,yBAA0BI,IAEvBI,EAAMC,mBAAS,gBAAgBC,YAAO,IAP5C,GASD,OACI,yBAAKT,UAAWK,GACZ,yCACIE,GAAIA,EACJb,IAAKA,EACLM,UAAU,sBACVU,cAAY,qBACZC,eAAcZ,EACdD,QAASA,EACTc,KAAK,WACLhB,KAAMA,EACNC,MAAOA,GACHO,IAER,2BAAOS,QAASN,EAAIP,UAAU,uBAC1B,0BAAMA,UAAU,6BAChB,0BAAMA,UAAU,4BAA4BL,QCxBjDmB,EA/BQ,SAAC,GAA0C,IAAxCC,EAAwC,EAAxCA,WAAwC,EAChCvB,IAAMgB,UAAS,GAAtCV,EADuD,KAC9CkB,EAD8C,OAE9BxB,IAAMgB,UAAS,GAAxCS,EAFuD,KAE7CC,EAF6C,KAG9D,OACI,6BACI,kBAAC3B,EAAD,CACIK,KAAK,YACLC,MAAM,WACNC,QAASA,EACTC,QAASgB,GAAcA,EAAW,YAClCZ,SAAUY,GAAcA,EAAU,UAClCb,aAAca,GAAcA,EAAU,QACtCI,SAAU,kBAAMH,GAAYlB,KAPhC,oFAWA,kBAACP,EAAD,CACIK,KAAK,YACLC,MAAM,YACNC,QAASmB,EACTlB,QAASgB,GAAcA,EAAW,YAClCZ,SAAUY,GAAcA,EAAU,UAClCb,aAAca,GAAcA,EAAU,QACtCI,SAAU,kBAAMD,GAAaD,KAPjC,qCCbL,IAAMG,EAAe,GAEtBC,EAAgB,SAAAzB,GAAI,OAAI,SAA6B0B,GAEzD,OADAC,QAAQC,KAAK,aAAe5B,EAAO,2EAC5B,kBAAS0B,KAGZG,EAAUJ,EAAc,WACxBK,EAAmBL,EAAc,oBACjCM,EAAc,CAClBP,gBAEIQ,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGT,E,oIACF,mBACD,OAAO,YAACM,EAAD,iBAAeD,EAAiBL,EAAhC,CAAuCS,WAAYA,EAAYC,QAAQ,cAI5E,YAACP,EAAD,CAASO,QAAQ,WAAjB,gRAKA,YAACN,EAAD,CAAkBO,UAAWnB,EAASoB,MAAO,CAC3CC,UAAW,CAAC,UAAW,WAAY,cAClCH,QAAQ,qBACX,8BACA,wPACA,wKAAuJ,kBAAII,WAAW,KAAf,cAAvJ,KACA,6CACA,mRACA,iRACA,sJAMJN,EAAWO,gBAAiB,G,kGC1B5B,IA8CI5B,EAAS,WAKX,IAJA,IAAI6B,EAAOC,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAK,GAC3EhC,EAAK,GACLmC,EAAQC,OAAOC,gBAAgB,IAAIC,WAAWP,IAE3CA,KAAQ,CAMb,IAAIQ,EAAqB,GAAdJ,EAAMJ,GAIf/B,GAFEuC,EAAO,GAEHA,EAAKC,SAAS,IACXD,EAAO,IAETA,EAAO,IAAIC,SAAS,IAAIC,cACtBF,EAAO,GACV,IAEA,IAIV,OAAOvC","file":"component---packages-checkbox-react-documentation-checkbox-mdx-ba32ba40c1e61f56bd6a.js","sourcesContent":["import React, { ReactNode, useState } from \"react\";\nimport classNames from \"classnames\";\nimport { nanoid } from \"nanoid\";\n\ninterface Props {\n    children: ReactNode;\n    name: string;\n    value: string;\n    checked?: boolean;\n    inline?: boolean;\n    className?: string;\n    forceCompact?: boolean;\n    invalid?: boolean;\n    inverted?: boolean;\n    onChange?: React.ChangeEventHandler<HTMLInputElement>;\n    onFocus?: React.FocusEventHandler<HTMLInputElement>;\n    onBlur?: React.FocusEventHandler<HTMLInputElement>;\n}\n\nexport const Checkbox = React.forwardRef<HTMLInputElement, Props>(\n    (\n        {\n            children,\n            name,\n            value,\n            checked,\n            invalid,\n            className,\n            inline = false,\n            forceCompact,\n            inverted,\n            ...eventHandlers\n        },\n        ref,\n    ) => {\n        const componentClassNames = classNames(\"jkl-checkbox\", className, {\n            \"jkl-checkbox--compact\": forceCompact,\n            \"jkl-checkbox--inline\": inline,\n            \"jkl-checkbox--error\": invalid,\n            \"jkl-checkbox--inverted\": inverted,\n        });\n        const [id] = useState(`jkl-checkbox-${nanoid(8)}`);\n\n        return (\n            <div className={componentClassNames}>\n                <input\n                    id={id}\n                    ref={ref}\n                    className=\"jkl-checkbox__input\"\n                    data-testid=\"jkl-checkbox-input\"\n                    aria-invalid={invalid}\n                    checked={checked}\n                    type=\"checkbox\"\n                    name={name}\n                    value={value}\n                    {...eventHandlers}\n                />\n                <label htmlFor={id} className=\"jkl-checkbox__label\">\n                    <span className=\"jkl-checkbox__check-mark\" />\n                    <span className=\"jkl-checkbox__check-text\">{children}</span>\n                </label>\n            </div>\n        );\n    },\n);\n","import React from \"react\";\nimport { ExampleComponentProps } from \"@fremtind/jkl-portal-components\";\nimport { Checkbox } from \"../src\";\n\nexport const Example = ({ boolValues }: ExampleComponentProps) => {\n    const [checked, setChecked] = React.useState(false);\n    const [checked2, setChecked2] = React.useState(false);\n    return (\n        <div>\n            <Checkbox\n                name=\"checklist\"\n                value=\"checkbox\"\n                checked={checked}\n                invalid={boolValues && boolValues[\"Med feil\"]}\n                inverted={boolValues && boolValues[\"Invertert\"]}\n                forceCompact={boolValues && boolValues[\"Kompakt\"]}\n                onChange={() => setChecked(!checked)}\n            >\n                Jeg vil bli kontaktet via telefon, i tillegg til at jeg vil motta brev på posten\n            </Checkbox>\n            <Checkbox\n                name=\"checklist\"\n                value=\"checkbox2\"\n                checked={checked2}\n                invalid={boolValues && boolValues[\"Med feil\"]}\n                inverted={boolValues && boolValues[\"Invertert\"]}\n                forceCompact={boolValues && boolValues[\"Kompakt\"]}\n                onChange={() => setChecked2(!checked2)}\n            >\n                Jeg vil bli kontaktet via epost\n            </Checkbox>\n        </div>\n    );\n};\n\nexport default Example;\n","import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/jokul/jokul/portal/src/components/Layout/DocPageLayout.tsx\";\nimport Example from \"./Example\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst Ingress = makeShortcode(\"Ingress\");\nconst ComponentExample = makeShortcode(\"ComponentExample\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n    <Ingress mdxType=\"Ingress\">\n    Når en avmerkingsboks står alene, er det gjerne for å bekrefte noe, for eksempel: \"Jeg bekrefter at opplysningene\n    jeg har gitt er riktige\". Vi bruker flere avmerkingsbokser sammen når vi vil gi brukerne en liste med valg, der de\n    kan velge ett eller flere alternativer.\n    </Ingress>\n    <ComponentExample component={Example} knobs={{\n      boolProps: [\"Kompakt\", \"Med feil\", \"Invertert\"]\n    }} mdxType=\"ComponentExample\" />\n    <h2>{`Bruk`}</h2>\n    <p>{`En gruppe avmerkingsbokser må ha en god overskrift, og ledeteksten til hver avmerkingsboks må beskrive alternativet. En avmerkingsboks som står alene trenger ikke noen overskrift, så lenge ledeteksten er god og beskrivende.`}</p>\n    <p>{`Du kan sette boksene under eller etter hverandre, men vi anbefaler at du plasserer dem under hverandre. Standard status for avmerkingsbokser er `}<em parentName=\"p\">{`ikke valgt`}</em>{`.`}</p>\n    <h2>{`Tekst og validering`}</h2>\n    <p>{`Velg størrelse på overskriften til en gruppe avmerkingsbokser etter prinsippene for skjemadesign. Ha en kort og tydelig overskrift, som beskriver hva brukeren skal velge. Hvis du trenger å gi mer forklaring, kan du sette en hjelpetekst under gruppen.`}</p>\n    <p>{`Hvis avmerkingsboksene ikke validerer, vises det en feilmelding som forklarer hva som er galt. Denne feilmeldingen erstatter en eventuell hjelpetekst du har der fra før, og bør formuleres slik at brukeren både får hjelp og får vite hva som er feil.`}</p>\n    <p>{`Eksempel:\nHjelpetekst: \"Oppgi fødselsnummeret ditt, 11 siffer\". Feilmelding: \"Du må oppgi fødselsnummeret ditt, 11 siffer\".`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      ","import \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.object.to-string\";\nimport \"core-js/modules/es6.typed.uint8-array\";\n// This file replaces `index.js` in bundlers like webpack or Rollup,\n// according to `browser` config in `package.json`.\nimport { urlAlphabet } from './url-alphabet/index.js';\n\nif (process.env.NODE_ENV !== 'production') {\n  // All bundlers will remove this block in the production bundle.\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative' && typeof crypto === 'undefined') {\n    throw new Error('React Native does not have a built-in secure random generator. ' + 'If you don’t need unpredictable IDs use `nanoid/non-secure`. ' + 'For secure IDs, import `react-native-get-random-values` ' + 'before Nano ID. If you use Expo, install `expo-random` ' + 'and use `nanoid/async`.');\n  }\n\n  if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {\n    throw new Error('Add `if (!window.crypto) window.crypto = window.msCrypto` ' + 'before Nano ID to fix IE 11 support');\n  }\n\n  if (typeof crypto === 'undefined') {\n    throw new Error('Your browser does not have secure random generator. ' + 'If you don’t need unpredictable IDs, you can use nanoid/non-secure.');\n  }\n}\n\nvar random = function random(bytes) {\n  return crypto.getRandomValues(new Uint8Array(bytes));\n};\n\nvar customRandom = function customRandom(alphabet, size, getRandom) {\n  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes\n  // values closer to the alphabet size. The bitmask calculates the closest\n  // `2^31 - 1` number, which exceeds the alphabet size.\n  // For example, the bitmask for the alphabet size 30 is 31 (00011111).\n  // `Math.clz32` is not used, because it is not available in browsers.\n  var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1; // Though, the bitmask solution is not perfect since the bytes exceeding\n  // the alphabet size are refused. Therefore, to reliably generate the ID,\n  // the random bytes redundancy has to be satisfied.\n  // Note: every hardware random generator call is performance expensive,\n  // because the system call for entropy collection takes a lot of time.\n  // So, to avoid additional system calls, extra bytes are requested in advance.\n  // Next, a step determines how many random bytes to generate.\n  // The number of random bytes gets decided upon the ID size, mask,\n  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance\n  // according to benchmarks).\n  // `-~f => Math.ceil(f)` if f is a float\n  // `-~i => i + 1` if i is an integer\n\n  var step = -~(1.6 * mask * size / alphabet.length);\n  return function () {\n    var id = '';\n\n    while (true) {\n      var bytes = getRandom(step); // A compact alternative for `for (var i = 0; i < step; i++)`.\n\n      var j = step;\n\n      while (j--) {\n        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.\n        id += alphabet[bytes[j] & mask] || ''; // `id.length + 1 === size` is a more compact option.\n\n        if (id.length === +size) return id;\n      }\n    }\n  };\n};\n\nvar customAlphabet = function customAlphabet(alphabet, size) {\n  return customRandom(alphabet, size, random);\n};\n\nvar nanoid = function nanoid() {\n  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 21;\n  var id = '';\n  var bytes = crypto.getRandomValues(new Uint8Array(size)); // A compact alternative for `for (var i = 0; i < step; i++)`.\n\n  while (size--) {\n    // It is incorrect to use bytes exceeding the alphabet size.\n    // The following mask reduces the random byte in the 0-255 value\n    // range to the 0-63 value range. Therefore, adding hacks, such\n    // as empty string fallback or magic numbers, is unneccessary because\n    // the bitmask trims bytes down to the alphabet size.\n    var byte = bytes[size] & 63;\n\n    if (byte < 36) {\n      // `0-9a-z`\n      id += byte.toString(36);\n    } else if (byte < 62) {\n      // `A-Z`\n      id += (byte - 26).toString(36).toUpperCase();\n    } else if (byte < 63) {\n      id += '_';\n    } else {\n      id += '-';\n    }\n  }\n\n  return id;\n};\n\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random };"],"sourceRoot":""}